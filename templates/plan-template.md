# **実装計画：[機能名]**

**ブランチ**: `[###-機能名]` | **日付**: [日付] | **仕様**: [リンク]
**入力**: `/specs/[###-機能名]/spec.md`からの機能仕様書

## **実行フロー（/plan コマンドのスコープ）**

```
1. 入力パスから機能仕様書を読み込む
   → 見つからない場合: エラー "指定パスに機能仕様書がありません: {path}"
2. 技術的コンテキストを埋める（`要確認`の箇所をスキャン）
   → コンテキストからプロジェクトタイプを検出（web=フロントエンド+バックエンド、mobile=アプリ+API）
   → プロジェクトタイプに基づいて構造の決定を設定
3. 下記の「開発原則チェック」セクションを評価
   → 違反がある場合: 「複雑性追跡」に文書化
   → 正当化できない場合: エラー "まずアプローチを簡素化してください"
   → 「進捗追跡」を更新: 初回開発原則チェック
4. フェーズ0を実行 → `research.md`
   → `要確認`が残っている場合: エラー "未解決の不明点を解消してください"
5. フェーズ1を実行 → `contracts`、`data-model.md`、`quickstart.md`、エージェント固有のテンプレートファイル（例：Claude Code用`CLAUDE.md`、GitHub Copilot用`.github/copilot-instructions.md`、Gemini CLI用`GEMINI.md`）。
6. 「開発原則チェック」セクションを再評価
   → 新たな違反がある場合: 設計をリファクタリングし、フェーズ1に戻る
   → 「進捗追跡」を更新: 設計後の開発原則チェック
7. フェーズ2を計画 → タスク生成アプローチを記述（`tasks.md`は**作成しない**）
8. 停止 - `/tasks`コマンドの準備完了
```

**重要**: `/plan`コマンドはステップ 7 で**停止**します。フェーズ 2〜4 は他のコマンドによって実行されます。

- フェーズ 2: `/tasks`コマンドが`tasks.md`を作成
- フェーズ 3〜4: 実装の実行（手動またはツール経由）

## **概要**

[機能仕様書から抽出: 主な要件 + 調査に基づく技術的アプローチ]

## **技術的コンテキスト**

**言語/バージョン**: [例：Python 3.11、Swift 5.9、Rust 1.75 または **要確認**]
**主要な依存関係**: [例：FastAPI、UIKit、LLVM または **要確認**]
**ストレージ**: [該当する場合。例：PostgreSQL、CoreData、ファイル または N/A]
**テスト**: [例：pytest、XCTest、cargo test または **要確認**]
**ターゲットプラットフォーム**: [例：Linux サーバー、iOS 15+、WASM または **要確認**]
**プロジェクトタイプ**: [単一/ウェブ/モバイル - ソースコード構造を決定]
**パフォーマンス目標**: [ドメイン固有。例：1000 リクエスト/秒、1 万行/秒、60fps または **要確認**]
**制約**: [ドメイン固有。例：p95 \< 200ms、メモリ \< 100MB、オフライン対応 または **要確認**]
**規模/範囲**: [ドメイン固有。例：ユーザー数 1 万人、コード量 100 万行、画面数 50 または **要確認**]

## **開発原則チェック**

_ゲート: フェーズ 0 の調査前に**必ず**通過。フェーズ 1 の設計後に再チェック。_

**シンプルさ**:

- プロジェクト数: [\#]（最大 3 つ。例：api、cli、tests）
- フレームワークを直接使用しているか？（ラッパークラスなし）
- 単一のデータモデルか？（シリアライズが異なる場合を除き DTO はなし）
- パターンを避けているか？（必要性が証明されない限り、リポジトリ/UoW は使用しない）

**アーキテクチャ**:

- すべての機能はライブラリとしてか？（直接のアプリケーションコードなし）
- ライブラリ一覧: [各ライブラリの名称と目的]
- ライブラリごとの CLI: [--help/--version/--format 付きのコマンド]
- ライブラリのドキュメント: `llms.txt`形式で計画されているか？

**テスト（厳守事項）**:

- RED-GREEN-Refactor サイクルが徹底されているか？（テストは最初に**必ず**失敗すること）
- Git のコミット履歴は実装前にテストを示しているか？
- 順序は、契約 → 結合 →E2E→ 単体テストが厳格に守られているか？
- 実際の依存関係を使用しているか？（モックではなく、実際の DB など）
- 新規ライブラリ、契約変更、共有スキーマに対する結合テストは？
- **禁止事項**: テスト前の実装、RED フェーズのスキップ

**可観測性**:

- 構造化されたロギングは含まれているか？
- フロントエンドのログ → バックエンドか？（統合されたストリーム）
- エラーコンテキストは十分か？

**バージョン管理**:

- バージョン番号は割り当てられているか？（`MAJOR.MINOR.BUILD`）
- 変更ごとに`BUILD`は増分されるか？
- 破壊的変更はどのように扱われるか？（並行テスト、移行計画）

## **プロジェクト構成**

### **ドキュメント（この機能用）**

```
specs/[###-機能]/
├── plan.md              # このファイル（/planコマンドの出力）
├── research.md          # フェーズ0の出力（/planコマンド）
├── data-model.md        # フェーズ1の出力（/planコマンド）
├── quickstart.md        # フェーズ1の出力（/planコマンド）
├── contracts/           # フェーズ1の出力（/planコマンド）
└── tasks.md             # フェーズ2の出力（/tasksコマンド - /planでは**作成されない**）
```

### **ソースコード（リポジトリのルート）**

```
# オプション1: 単一プロジェクト（デフォルト）
src/
├── models/
├── services/
├── cli/
└── lib/

tests/
├── contract/
├── integration/
└── unit/

# オプション2: ウェブアプリケーション（"frontend" + "backend"が検出された場合）
backend/
├── src/
│   ├── models/
│   ├── services/
│   └── api/
└── tests/

frontend/
├── src/
│   ├── components/
│   ├── pages/
│   └── services/
└── tests/

# オプション3: モバイル + API（"iOS/Android"が検出された場合）
api/
└── [上記backendと同じ]

ios/ または android/
└── [プラットフォーム固有の構造]
```

**構造の決定**: [技術的コンテキストがウェブ/モバイルアプリを示す場合を除き、オプション 1 を**デフォルト**とする]

## **フェーズ 0：アウトラインと調査**

1.  **上記の技術的コンテキストから不明点を抽出**:

    - `要確認`の各項目 → 調査タスク
    - 各依存関係 → ベストプラクティスのタスク
    - 各結合 → パターンに関するタスク

2.  **調査エージェントを生成して実行**:

    ```
    技術的コンテキストの不明点ごとに:
      タスク: "{機能のコンテキスト}における{不明点}の調査"
    技術の選択ごとに:
      タスク: "{ドメイン}における{技術}のベストプラクティスを調査"
    ```

3.  **調査結果を`research.md`に統合**（形式は以下）：

    - 決定: [選択された内容]
    - 理由: [選択理由]
    - 検討した代替案: [評価した他の案]

**出力**: すべての`要確認`が解決された`research.md`

## **フェーズ 1：設計と契約**

_前提条件: `research.md`が完了していること_

1.  **機能仕様書からエンティティを抽出** → `data-model.md`:

    - エンティティ名、フィールド、関係
    - 要件からのバリデーションルール
    - 該当する場合、状態遷移

2.  **機能要件から API 契約を生成**:

    - 各ユーザーアクション → エンドポイント
    - 標準的な REST/GraphQL パターンを使用
    - OpenAPI/GraphQL スキーマを`/contracts/`に出力

3.  **契約から契約テストを生成**:

    - エンドポイントごとに 1 つのテストファイル
    - リクエスト/レスポンスのスキーマをアサート
    - テストは失敗すること（まだ実装はないため）

4.  **ユーザーストーリーからテストシナリオを抽出**:

    - 各ストーリー → 結合テストシナリオ
    - クイックスタートテスト = ストーリーの検証手順

5.  **エージェントファイルを段階的に更新**（O(1)の操作）：

    - AI アシスタントに合わせて`/scripts/update-agent-context.sh [claude|gemini|copilot]`を実行
    - 既に存在する場合: 現在の計画からの**新しい**技術のみを追加
    - マーカー間の手動追加分は保持
    - 最近の変更点を更新（直近 3 つを保持）
    - トークン効率のため 150 行未満に保つ
    - リポジトリのルートに出力

**出力**: `data-model.md`、`/contracts/*`、失敗するテスト、`quickstart.md`、エージェント固有のファイル

## **フェーズ 2：タスク計画アプローチ**

_このセクションは、`/tasks`コマンドが実行する内容を記述するものであり、`/plan`の実行中には**実行しない**。_

**タスク生成戦略**:

- `/templates/tasks-template.md`をベースとして読み込む
- フェーズ 1 の設計ドキュメント（契約、データモデル、クイックスタート）からタスクを生成
- 各契約 → 契約テストタスク [P]
- 各エンティティ → モデル作成タスク [P]
- 各ユーザーストーリー → 結合テストタスク
- テストをパスさせるための実装タスク

**順序付け戦略**:

- TDD 順序: 実装の前にテスト
- 依存関係順序: UI より前にサービス、サービスより前にモデル
- `[P]`は並行実行可能（独立したファイル）としてマーク

**推定出力**: `tasks.md`に 25〜30 個の番号付きの順序付けられたタスク

**重要**: このフェーズは`/tasks`コマンドによって実行され、`/plan`では実行されない。

## **フェーズ 3 以降：将来の実装**

_これらのフェーズは、`/plan`コマンドのスコープ外_

**フェーズ 3**: タスクの実行（`/tasks`コマンドが`tasks.md`を作成）
**フェーズ 4**: 実装（開発原則に従って`tasks.md`を実行）
**フェーズ 5**: 検証（テストの実行、`quickstart.md`の実行、パフォーマンス検証）

## **複雑性追跡**

_開発原則チェックに違反があり、正当化が必要な場合**のみ**記入_

| 違反内容                   | なぜ必要か     | 拒否されたよりシンプルな代替案の理由   |
| -------------------------- | -------------- | -------------------------------------- |
| [例：4 番目のプロジェクト] | [現在の必要性] | [3 つのプロジェクトでは不十分な理由]   |
| [例：リポジトリパターン]   | [特定の問題]   | [直接的な DB アクセスでは不十分な理由] |

## **進捗追跡**

_このチェックリストは、実行フロー中に更新される_

**フェーズのステータス**:

- [ ] フェーズ 0: 調査完了（`/plan`コマンド）
- [ ] フェーズ 1: 設計完了（`/plan`コマンド）
- [ ] フェーズ 2: タスク計画完了（`/plan`コマンド - アプローチのみ記述）
- [ ] フェーズ 3: タスク生成完了（`/tasks`コマンド）
- [ ] フェーズ 4: 実装完了
- [ ] フェーズ 5: 検証合格

**ゲートのステータス**:

- [ ] 初回開発原則チェック: 合格
- [ ] 設計後の開発原則チェック: 合格
- [ ] すべての`要確認`が解決済み
- [ ] 複雑性に関する逸脱は文書化済み

---

_開発原則 v2.1.1 に基づく - `/memory/constitution.md`を参照_
